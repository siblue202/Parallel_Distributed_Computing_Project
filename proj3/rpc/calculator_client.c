/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "calculator.h"

#define MAX_LEN 100

struct Stack {
	char operator[MAX_LEN];
	int operand[MAX_LEN];
	int opt_top;
	int opd_top;
};

struct Stack stack;

void init_stack() {
	stack.opt_top = 0;
	stack.opd_top = 0;
}

void optPush(char opt) {
	stack.operator[stack.opt_top++] = opt;
}

void opdPush(int opd) {
	stack.operand[stack.opd_top++] = opd;
}

char optPop() {
	return stack.operator[--stack.opt_top];
}

int opdPop() {
	return stack.operand[--stack.opd_top];
}

void resetExpression(char exp[], int len) {
	int i;
	for (i=0; i < len; i++) exp[i] = '\0';
}

int optCheck(char opt1, char opt2) {
	if (opt1 == '*' || opt1 == '/' || opt1 == '^') {
		if (opt2 == '+' || opt2 == '-') return 1;
		else return 0;
	}
	else return 0;
}

int calFunc(CLIENT *clnt, int opd1, int opd2, char opt) {
	void *result;
	struct param_int param;
	param.x = opd1;
	param.y = opd2;

	switch(opt) {
		case '+' : 
			result = calculate_add_1(&param, clnt);
			if (result == (int *) NULL) {
				clnt_perror (clnt, "call failed");
			}
			break;
		case '-' : 
			result = calculate_sub_1(&param, clnt);
			if (result == (int *) NULL) {
				clnt_perror (clnt, "call failed");
			}
			break;
		case '*' : 
			result = calculate_mul_1(&param, clnt);
			if (result == (int *) NULL) {
				clnt_perror (clnt, "call failed");
			}
			break;
		case '/' : 
			result = calculate_div_1(&param, clnt);
			if (result == (int *) NULL) {
				clnt_perror (clnt, "call failed");
			}
			break;
		case '^' : 
			result = calculate_pow_1(&param, clnt);
			if (result == (int *) NULL) {
				clnt_perror (clnt, "call failed");
			}
			break;
	}
	int res = *(int *)result;
	return res;
}

int
main (int argc, char *argv[])
{
	int i;
	CLIENT *clnt;
	void *result;

	if (argc != 3) {
		printf ("usage: %s server_host cal_string\n", argv[0]);
		exit (1);
	}
	clnt = clnt_create(argv[1], CAL_PROG, CAL_VERS, "udp");

	if (clnt == (CLIENT *)NULL) {
		clnt_pcreateerror(argv[1]);
		exit(1);
	}
	
	char expression[MAX_LEN] = {0, };
	int j = strlen(argv[2]);
	int exp_i = 0;
	for (i=0; i<j; i++) {
		if (argv[2][i] == '*' && argv[2][i+1] == '*') {
			expression[exp_i++] = '^';
			i++;
		} else {
			expression[exp_i++] = argv[2][i];
		}
	}
	int len = strlen(expression);

	init_stack();

	char tmpExp[MAX_LEN] = {0, };
	char ch, opt;
	int tmpCnt = 0;
	int opd1, opd2, res, flag = 0;
	for (i=0; i < len; i++) {
		ch = expression[i];
		opt = 0;
		if (ch == ' ') 
			continue;
		else if (ch >= '0' && ch <= '9') {
			tmpExp[tmpCnt++] = ch;
			if (expression[i+1] == '(' || expression[i+1] == ')' || expression[i+1] == '+' || expression[i+1] == '-' \
			|| expression[i+1] == '*' || expression[i+1] == '/' || expression[i+1] == '^' || expression[i+1] == '\0') {
				opdPush(atoi(tmpExp));
				resetExpression(tmpExp, tmpCnt);
				tmpCnt = 0;
			}
		}
		else if (ch == '+' || ch == '-' || ch == '*' || ch == '/' || ch == '^') {
			if (stack.opt_top == 0)
				optPush(ch);
			else {
				opt = optPop();
				if (optCheck(opt, ch)) {
					opd2 = opdPop();
					opd1 = opdPop();
					res = calFunc(clnt, opd1, opd2, opt);
					opdPush(res);
					optPush(ch);
				} else {
					optPush(opt);
					optPush(ch);
				}
			}
		}
		else if (ch = '(') optPush(ch);
		else if (ch == ')') {
			while (opt != '(') {
				opt = optPop();
				if (opt != '(') {
					opd2 = opdPop();
					opd1 = opdPop();
					res = calFunc(clnt, opd1, opd2, opt);
					opdPush(res);
				}
			}
		}
		else if (ch == '\0') break;
	}

	while (stack.opt_top != 0) {
		opd2 = opdPop();
		opd1 = opdPop();
		opt = optPop();
		res = calFunc(clnt, opd1, opd2, opt);
		opdPush(res);
	}

	printf("The answer is %d\n", opdPop());	

	clnt_destroy(clnt);
	exit (0);
}
